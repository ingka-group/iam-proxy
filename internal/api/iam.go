// Copyright Â© 2024 Ingka Holding B.V. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package api IAM API
//
// Simple IAM verification procedure for OAuth2 authentication cycles. Generates a token for
// a valid user with expiration time, and provides functionality for the validation of tokens.
//
//	    Schemes: http, https
//		Host: localhost:8080
//	    BasePath: /iam/v1
//		Version: APP_VERSION_AUTOGENERATED
//
//	    Produces:
//	    - application/json
//
// swagger:meta
//
//go:generate swagger generate spec -m -o ../../docs/swagger/iam.json
package api

import (
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/gin-gonic/gin"
	"go.uber.org/zap"

	jwt "github.com/ingka-group-digital/iam-proxy/client/http"
	"github.com/ingka-group-digital/iam-proxy/client/iam"
	"github.com/ingka-group-digital/iam-proxy/internal/logger"
)

// swagger:route POST /oauth2/token token
//
// Responds with an access token.
//
//		Produces:
//		- application/json
//
//		Responses:
//		  200: body:token
//	      400:
//	      401:
//
// Example: $ curl -d "client_id=<your-client-id>&client_secret=<your-client-secret>&grant_type=client_credentials" https://<domain>/iam/v1/oauth2/token
func (cl *Client) Token(c *gin.Context) {
	log := logger.FromContext(c.Request.Context()).Sugar()

	defer c.Request.Body.Close()

	body, err := io.ReadAll(c.Request.Body)
	if err != nil {
		log.Errorw("Failed to read body", zap.Error(err))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	v, err := url.ParseQuery(string(body))
	if err != nil {
		log.Errorw("Failed to parse data", zap.Error(err))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	if clID, ok := v[iam.ClientIDKey]; !ok || len(clID) == 0 {
		log.Errorw("client id '%s' is missing", iam.ClientIDKey, zap.Error(err))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	if clSecret, ok := v[iam.ClientSecretKey]; !ok || len(clSecret) == 0 {
		log.Errorw("client secret '%s' is missing", iam.ClientSecretKey, zap.Error(err))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}

	accessToken, identityToken, expiresIn, err := cl.cfg.Service.GenerateToken(c.Request.Context(), v[iam.ClientIDKey][0], v[iam.ClientSecretKey][0])
	if err != nil {
		log.Errorw("Failed to generate token", zap.Error(err),
			zap.String("client-id", v[iam.ClientIDKey][0]),
			zap.String("client-secret", v[iam.ClientSecretKey][0]))
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}
	c.JSON(http.StatusOK, iam.Token{
		TokenType:     "Bearer",
		ExpiresIn:     expiresIn,
		ExtExpiresIn:  expiresIn,
		AccessToken:   accessToken,
		IdentityToken: identityToken,
	})
}

// swagger:route POST /oauth2/validate validate
//
// Responds with an error if the token is not valid.
//
//		Responses:
//		  200:
//	      400:
//	      401:
func (cl *Client) Validate(c *gin.Context) {
	log := logger.FromContext(c.Request.Context()).Sugar()
	token, err := jwt.ExtractAccessToken(c.Request)
	if err != nil {
		log.Errorw("token missing", zap.Error(fmt.Errorf("token missing from header")))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}
	_, err = cl.cfg.Service.ParseToken(token)
	if err != nil {
		log.Errorw("Failed to validate token", zap.Error(err))
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}
	c.JSON(http.StatusOK, nil)
}

// swagger:route POST /oauth2/identity identity
//
// Responds with the subject embedded in the token claims, if there is one.
// If the token is invalid, an error is returned.
//
//		Produces:
//		- application/json
//
//		Responses:
//		  200: body:tokenIdentity
//	      400:
//	      401:
func (cl *Client) Identity(c *gin.Context) {
	log := logger.FromContext(c.Request.Context()).Sugar()
	token, err := jwt.ExtractIdentityToken(c.Request)
	if err != nil {
		log.Errorw("token missing", zap.Error(fmt.Errorf("token missing from header")))
		c.AbortWithStatus(http.StatusBadRequest)
		return
	}
	sub, err := cl.cfg.Service.ParseToken(token)
	if err != nil {
		log.Errorw("Failed to validate token", zap.Error(err))
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}
	if len(sub) == 0 {
		log.Errorw("Subject is empty", zap.Error(err))
		c.AbortWithStatus(http.StatusBadRequest)
	}

	c.JSON(http.StatusOK, iam.TokenIdentity{
		Identity: sub,
	})
}
